import { Contracts } from '../lib/Contracts';
import { address, AccountStatus, Balance, Decimal, Index, Integer, Market, MarketWithInfo, RiskLimits, RiskParams, TotalPar, Values, CallOptions } from '../types';
export declare class Getters {
    private contracts;
    constructor(contracts: Contracts);
    getMarginRatio(options?: CallOptions): Promise<Decimal>;
    getLiquidationSpread(options?: CallOptions): Promise<Decimal>;
    getEarningsRate(options?: CallOptions): Promise<Decimal>;
    getMinBorrowedValue(options?: CallOptions): Promise<Integer>;
    getRiskParams(options?: CallOptions): Promise<RiskParams>;
    getRiskLimits(options?: CallOptions): Promise<RiskLimits>;
    getNumMarkets(options?: CallOptions): Promise<Integer>;
    getMarketTokenAddress(marketId: Integer, options?: CallOptions): Promise<address>;
    getMarketTotalPar(marketId: Integer, options?: CallOptions): Promise<TotalPar>;
    getMarketCachedIndex(marketId: Integer, options?: CallOptions): Promise<Index>;
    getMarketCurrentIndex(marketId: Integer, options?: CallOptions): Promise<Index>;
    getMarketPriceOracle(marketId: Integer, options?: CallOptions): Promise<address>;
    getMarketInterestSetter(marketId: Integer, options?: CallOptions): Promise<address>;
    getMarketMarginPremium(marketId: Integer, options?: CallOptions): Promise<Decimal>;
    getMarketSpreadPremium(marketId: Integer, options?: CallOptions): Promise<Decimal>;
    getMarketIsClosing(marketId: Integer, options?: CallOptions): Promise<boolean>;
    getMarketPrice(marketId: Integer, options?: CallOptions): Promise<Integer>;
    getMarketUtilization(marketId: Integer, options?: CallOptions): Promise<Decimal>;
    getMarketInterestRate(marketId: Integer, options?: CallOptions): Promise<Decimal>;
    getMarketSupplyInterestRate(marketId: Integer, options?: CallOptions): Promise<Decimal>;
    getLiquidationSpreadForPair(heldMarketId: Integer, owedMarketId: Integer, options?: CallOptions): Promise<Decimal>;
    getMarket(marketId: Integer, options?: CallOptions): Promise<Market>;
    getMarketWithInfo(marketId: Integer, options?: CallOptions): Promise<MarketWithInfo>;
    getNumExcessTokens(marketId: Integer, options?: CallOptions): Promise<Integer>;
    getAccountPar(accountOwner: address, accountNumber: Integer, marketId: Integer, options?: CallOptions): Promise<Integer>;
    getAccountWei(accountOwner: address, accountNumber: Integer, marketId: Integer, options?: CallOptions): Promise<Integer>;
    getAccountStatus(accountOwner: address, accountNumber: Integer, options?: CallOptions): Promise<AccountStatus>;
    getAccountValues(accountOwner: address, accountNumber: Integer, options?: CallOptions): Promise<Values>;
    getAdjustedAccountValues(accountOwner: address, accountNumber: Integer, options?: CallOptions): Promise<Values>;
    getAccountBalances(accountOwner: address, accountNumber: Integer, options?: CallOptions): Promise<Balance[]>;
    isAccountLiquidatable(liquidOwner: address, liquidNumber: Integer, options?: CallOptions): Promise<boolean>;
    getIsLocalOperator(owner: address, operator: address, options?: CallOptions): Promise<boolean>;
    getIsGlobalOperator(operator: address, options?: CallOptions): Promise<boolean>;
    getAdmin(options?: CallOptions): Promise<address>;
    getExpiryAdmin(options?: CallOptions): Promise<address>;
    getExpiry(accountOwner: address, accountNumber: Integer, marketId: Integer, options?: CallOptions): Promise<Integer>;
    getExpiryPrices(heldMarketId: Integer, owedMarketId: Integer, expiryTimestamp: Integer, options?: CallOptions): Promise<{
        heldPrice: Integer;
        owedPrice: Integer;
    }>;
    getExpiryRampTime(options?: CallOptions): Promise<Integer>;
    private parseIndex;
    private parseTotalPar;
}
